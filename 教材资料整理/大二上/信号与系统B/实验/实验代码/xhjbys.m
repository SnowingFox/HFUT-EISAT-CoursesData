% Copyright (c) 1997-2000 by TH Technology, Inc.
% All Rights Reserved.
% Date: 2006/01/02
clear
clf reset
H=axes( 'unit' , 'normalized' , 'position' ,[0,0,1,1], 'visible' , 'off' );
set(gcf, 'currentaxes' ,H);
h_fig=get(H, 'parent' );
set(h_fig, 'menubar','none','unit' , 'normalized' , 'color',[0.7 0.7 0.7],'position' ,[0.18,0.2,0.65,0.52]);
str= ' 信号的基本运算 ' ;
set(gcf, 'name' ,str,'color',[0.7 0.7 0.9], 'numbertitle' , 'off' ); % 书写图形窗名
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.38,0.88,0.3,0.08], ...
'horizontal' , 'left' , 'fontsize' ,15,'fontname',' 行书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{ '信号的基本运算' });
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'HorizontalAlignment','left','position' ,[0.07,0.85,0.92,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{ '信号的尺度变换、翻转、平移（时移）运算，实际上是函数自变量的运算。在信号的尺度变换f(at)'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.80,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'和f[Mk]中，函数的自变量乘以一个常数，在MATLAB中可用算术运算符“*”来实现。在信号翻转f(-t)和'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.75,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'和f[-k]运算中,函数的自变量乘以一个负号，在MATLAB中可以直接用负号“-”写出。翻转运算在MATLAB'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'HorizontalAlignment','left','position' ,[0.03,0.70,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'中还可以利用fliplr(f)函数来实现，而翻转后信号坐标则可由-fliplr(k)得到。在信号时移 f(t±t0)和f[k±k0]'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'HorizontalAlignment','left','position' ,[0.03,0.65,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'运算中，函数自变量加、减一个常数，在MATLAB中可用算术运算符“+”或者“-”来实现。'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'HorizontalAlignment','left','position' ,[0.07,0.60,0.92,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{ '卷积是用来计算系统零状态响应的有力工具，对于连续时间系统，有y(t)=x(t)*h(t)，其中h(t)为系统'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.55,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'传递函数（即冲激响应）；对于离散时间系统，有y[n]=x[n]*h[n]，其中h[n]为系统传递函数（即单位冲'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.50,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'激）响应。MATLAB信号处理工具箱提供了一个计算两个离散序列卷积和的函数conv，其调用形式为：'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.45,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'c=conv(a,b)  式中a、b分别为待卷积的两序列的向量表示，c是卷积结果。向量c的长度为向量a、b的长'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.40,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'度之和减1，即length(c)=length(a)+length(b)-1。'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.07,0.35,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'卷积积分的运算实际上可利用信号的分段求和来实现。利用MATLAB计算连续信号的卷积，是通过'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.30,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'离散序列的卷积和来近似实现。将连续信号f1(t)、f2(t)以相等的时间间隔进行取样，得到离散序列'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.25,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'f1(k1Δ)、f2(k2Δ)…。在MATLAB中，函数conv()、函数deconv()可用来求两个离散序列的卷积和去卷'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.20,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'积，conv()函数的调用格式为：f=conv(f1,f2)，deconv()函数的调用格式为：[f,k]=deconv(f1,f2,k1,k2)。'});
h_text=uicontrol(h_fig, 'style' , 'text' , ...
'unit' , 'normalized' , 'position' ,[0.03,0.15,0.98,0.04], ...
'horizontal' , 'left' , 'fontsize' ,10,'fontname',' 隶书' ,'foregroundcolor','blue','backgroundcolor',[0.7 0.7 0.9],'string' ,{'要注意的是k如何确定。'});

h_push=uicontrol(h_fig, 'style' , 'push' , ...
'unit' , 'normalized' ,'fontname','行书' ,'foregroundcolor','blue', 'backgroundcolor',[0.7 0.7 0.9],'position' ,[0.57,0.08,0.15,0.09], ...
'fontsize' ,12,'string' , '下一步' , 'callback' , 'xhdjbys' );
h_push=uicontrol(h_fig, 'style' , 'push' , ...
'unit' , 'normalized' ,'fontname','行书' ,'foregroundcolor','blue', 'backgroundcolor',[0.7 0.7 0.9],'position' ,[0.77,0.08,0.15,0.09], ...
'fontsize' ,12,'string' , '返回目录' , 'callback' , 'syxm' );